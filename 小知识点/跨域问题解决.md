# 跨域解决

跨域也有很多解决方案：JSONP，iframe，代理，反向代理等

> Access-Control-Allow-Origin: *

## 预请求

此规则规定，处于跨域环境并在下面几个条件下，浏览器会发送两个请求给服务器；

举例说明：假设客户端需要发起 PUT 请求

1. 首先，客户端要发送 **OPTIONS 请求** 给服务器。
2. 在 服务器内部，需要对 **OPTIONS 请求** ，做出一些 **设定** ，告诉客户端 **是否允许访问** 。
3. 客户端确认服务器允许该方法，最终发送 PUT 请求；否则，抛出错误，服务器拒绝访问此方法。

**这种设定保证了服务器的 安全性，服务器可控制客户端访问的内容 ！！！**

触发预请求有三种情况：

1. 使用了某些方法，比如说 PUT, DELETE 等。
2. Fetch 规范规定了对 CORS安全的首部字段集合，人为设置会触发预请求。
3. Content-Type的值不是`text/plain` ，`multipart/form-data`，`application/x-www-form-urlencoded`



## 对于非预处理请求 

只要设置 

> Access-Control-Allow-Origin: *

## 有预处理请求的

```js
const http = require('http');

const server = http.createServer((request, response) => {
    if (request.url === '/') {
        if (request.method === 'GET') {
            response.writeHead(200, {
                'Access-Control-Allow-Origin': '*'
            });
            response.end("{name: 'BruceLee', password: '123456'}");
        }

        if (request.method === 'POST') {
            response.writeHead(200, {
                'Access-Control-Allow-Origin': '*'
            });

            response.end( JSON.stringify({state: true}) );
        }

        if (request.method === 'OPTIONS') {	
            response.writeHead(200, {
                'Access-Control-Allow-Origin': '*',	 // 设置 optins 方法允许所有服务器访问 
                'Access-Control-Allow-Methods': '*', // 允许访问路径 '/' POST等所有方法
                'Access-Control-Allow-Headers': 'Content-Type',	// 允许类 Content-Type 头部 
            });
        }
    }

    response.end('false');
});

server.listen(3000, () => {
    console.log('The server is running at http://localhost:3000');
});
```

