# 1. socket

ipc本地进程间的通讯

udp套接字
```python 
import socket

# 创建套接字
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# 准备接收方的地址
sendAddr = ("127.0.0.1", 8080)

# 发送
s.sendto(b"skdfsksdjfks",sendAddr) # "".encode("utf-8")
s.close()
```
接收方 需要绑定IP跟端口
```python
from socket import *

udpsocket = socket(AF_INET, SOCK_DGRAM)

bindAddr = ("", 8080)
udpsocket.bind(bindAddr)  # 绑定本机的任何一个IP

#等待接收对方发送的数据
while True:
    receiveData = udpsocket.recvfrom(1024)
    print(receiveData[0].decode("utf-8"))
```
udp应用:echo服务器
```python
receiveData, address = udpsocket.recvfrom(10000)
    # sumData += address+":"+receiveData+"\n"
    #回应
    udpsocket.sendto(receiveData,address)
```
一个简单的聊天程序
```python
from socket import *
import threading

# 1. 收数据，然后打印
# 2. input 发送数据
udpSocket = socket(AF_INET, SOCK_DGRAM)
udpSocket.bind(("",8081))

sendAddr = ("127.0.0.1",8080)

def recvData():
    while True:
        recvInfo = udpSocket.recvfrom(1024)
        print("\n>>%s:%s\n<<" % (str(recvInfo[1]), recvInfo[0].decode("utf-8")),end="")


def sendData():
    while True:
        sendInfo = input("<<")
        udpSocket.sendto(sendInfo.encode("utf-8"), sendAddr)


def main():
    tr = threading.Thread(target=recvData)
    ts = threading.Thread(target=sendData)

    tr.start()
    ts.start()
    tr.join()
    ts.join()


if __name__ == "__main__":
    main()
```

# 2. TFTP简单文本传输协议

c:读写请求：1/2操作码，文件名，0，octet（模式），0

s:数据包：3操作码(2byte)，**块编号**(2byte)，数据(512byte)

c:确认请求ack：4操作码 块编号

s:error：5操作码，差错码，差错信息，0

```python
# 构造下载请求数据 (大端，小端)
# 低位存放低，高位存放高就叫小端
# !表示大端法，H表示两个字节，
# "!H8sb5sb"

from socket import *
import struct

# 用pack 打包数据成 字节形式
sendData = struct.pack("!H8sb5sb", 1, "test.jpg".encode("utf-8"), 0, "octet".encode("utf-8"), 0)
udpSocket = socket(AF_INET, SOCK_DGRAM)
udpSocket.sendto(sendData, ("8.8.8.8", 69))
# unpack解包字节 成元组形式
result = struct.unpack("!H8sb5sb",sendData)
print(result)
udpSocket.close()

```

```python
import struct
from socket import *
import time
import os

def main():


	#0. 获取要下载的文件名字:
	downloadFileName = raw_input("请输入要下载的文件名:")	

	#1.创建socket
	udpSocket = socket(AF_INET, SOCK_DGRAM)

	requestFileData = struct.pack("!H%dsb5sb"%len(downloadFileName), 1, downloadFileName, 0, "octet", 0)

	#2. 发送下载文件的请求
	udpSocket.sendto(requestFileData, ("192.168.119.215", 69))

	flag = True #表示能够下载数据，即不擅长，如果是false那么就删除
	num = 0
	f = open(downloadFileName, "w")

	while True:
		#3. 接收服务发送回来的应答数据
		responseData = udpSocket.recvfrom(1024)

		# print(responseData)
		recvData, serverInfo = responseData

		opNum = struct.unpack("!H", recvData[:2])

		packetNum = struct.unpack("!H", recvData[2:4])

		print(packetNum[0])

		# print("opNum=%d"%opNum)
		# print(opNum)

		# if 如果服务器发送过来的是文件的内容的话:
		if opNum[0] == 3: #因为opNum此时是一个元组(3,)，所以需要使用下标来提取某个数据
			

			#计算出这次应该接收到的文件的序号值，应该是上一次接收到的值的基础上+1
			num = num + 1

			# 如果一个下载的文件特别大，即接收到的数据包编号超过了2个字节的大小
			# 那么会从0继续开始，所以这里需要判断，如果超过了65535 那么就改为0
			if num==65536:
				num = 0

			# 判断这次接收到的数据的包编号是否是 上一次的包编号的下一个
			# 如果是才会写入到文件中，否则不能写入（因为会重复）
			if num == packetNum[0]:
				# 把收到的数据写入到文件中
				f.write(recvData[4:])
				num = packetNum[0]

			#整理ACK的数据包
			ackData = struct.pack("!HH", 4, packetNum[0])
			udpSocket.sendto(ackData, serverInfo)

		elif opNum[0] == 5:
			print("sorry，没有这个文件....")
			flag = False

		# time.sleep(0.1)

		if len(recvData)<516:
			break

	if flag == True:
		f.close()
	else:
		os.unlink(downloadFileName)#如果没有要下载的文件，那么就需要把刚刚创建的文件进行删除

if __name__ == '__main__':
	main()

```

# 3. udp广播(tcp不能广播)

```Python
import socket,sys

s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
# 配置广播参数
s.setsockopt(socket.SOL_SOCKET,socket.SO_BROADCAST,1)
s.sendto("hi",("<broadcast>",7788))
while True:
    (buf,address) = s.recvfrom(1024)
```

# 4. TCP 传输控制协议

udp（用户数据包协议）通信模型，开始前不需要建立相关连接，但是tcp要

socket默认创建的是主动套接字，listen（）将其变为被动套接字

服务器
```python
from socket import *
from multiprocessing import Process

server = socket(AF_INET, SOCK_STREAM)  # 创建tcp套接字

server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
server.bind(("", 10001))  # 绑定

server.listen(5)  # 最多有几个客户端连接上来


def clientDeal(clientSocket):
    while True:
        recvData = clientSocket.recv(1024)
        if len(recvData) > 0:
            print("recv:" + recvData.decode("utf-8"))
            # sendData = input("请输入回复：")
            # clientSocket.send(sendData)
        else:
            clientSocket.close()
            break

def main():
    while True:
        # 如果有新的客户端连接服务器，那么tcp会产生一个新的套接字来处理这个连接
        clientSocket, clientAddr = server.accept()
        # 每个套接字进行任务
        p = Process(target=clientDeal,args=(clientSocket,))
        p.start()

if __name__ == "__main__":
    main()
```
客户端
```python
from socket import *

s = socket(AF_INET,SOCK_STREAM)

s.connect(("127.0.0.1",8080))
s.send("sss".encode("utf-8"))

s.close()
```

# 5. ICMP ARP （与IP同一层）

主要是供交换机学习
1. arp:获取Mac地址，广播形式发(ip->mac)
2. rarp:通过Mac->ip
3. ICMP:ping的时候会发送

Mac地址在路由器上回变化，但是ip地址是不会变化的。

tcp三次握手：syn syn+ack ack

tcp四次挥手：fin，ack ，fin ，ack

然后每次tcp发送完数据，另一方都会发回ack，稳定

# 6. tcp

1. tcp的十总状态：

	a. syn_sent

	b. listen

	c. syn_recv

	d. established

	e. fin_wait1

	f. close_wait

	g. fin_wait2

	h. last_ack

	i. time_wait

	j. closed

2. 常见的攻击

Python使用原始套接字
	1. DDos拒绝服务式攻击 tcp半连接 syn洪水
	2. dns劫持
	3. nslookup baidu.com查看对应的ip
	4. ARP劫持

3. 单进程的多任务服务器

```python
from socket import *

server = socket(AF_INET, SOCK_STREAM)  # 创建tcp套接字

server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
server.setblocking(False)  # 设置为不阻塞

server.bind(("", 10001))  # 绑定
server.listen(5)  # 最多有几个客户端连接上来,然后放在一个队列中

clientAddrList = []  # 保存所有已经连接的客户端信息
while True:
    # 如果设置成了不阻塞，那么在没有connect过来之前会抛出异常
    try:
        clientSocket, clientAddr = server.accept()  # 因为设置了不阻塞，所以这里不会阻塞
    except:
        pass
    else:
        clientSocket.setblocking(False)
        clientAddrList.append((clientSocket, clientAddr))
        print(clientAddr)

    for clientSocket, clientAddr in clientAddrList:
        try:
            recvData = clientSocket.recv(1024)
        except:
            pass
        else:
            if len(recvData) > 0:
                print(recvData)
            else:
                clientSocket.close()
                clientAddrList.remove((clientSocket,clientAddr))
```

select 能够完成对一些套接字的检测

```python
import select
from socket import *
import sys

server = socket(AF_INET,SOCK_STREAM)
server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
server.bind("",11111)
server.listen(4)

inputs = [server,sys.stdin]
while True:
	readable,writeable,exceptional = select.select(inputs,[],[])

	for sock in readable:
		if sock == server:
			conn,addr = server.accept()
			inputs.append(conn)
		
		else:
			data = sock.recv(1024)
			if data:
				sock.send(data)
			else:
				inputs.remove(sock)

```
select 并发量 最多1024 轮询的机制

poll 解决了套接字有上限的问题 轮询机制

epoll 事件通知机制

```python
import select
from socket import *
import sys

server = socket(AF_INET,SOCK_STREAM)
server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
server.bind("",11111)
server.listen(4)

epoll  = select.epoll()
# 注册事件到epoll中
# 如果fd已经被注册了，就会抛出异常
# 将创建的套接字直接添加到epoll的事件监听中去
epoll.register(server.fileno(),select.EPOLLIN|select.EPOLLET)

connections = {}
address = {}

while True:
	# 检测所有能够收发的套接字
	epoll_list = epoll.poll()
	# 文件描述符，事件（读，写）
	for fd,events in epoll_list: # 事件检测机制 epoll_list列表中存放的就是
		if fd == server.fileno():
			connSocket,addr = server.accept()
			connections[connSocket.fileno()] = connSocket
			addresses[connSocket.fileno()] = addr
			epoll.register(connSocket.fileno(),select.EPOLLIN|select.EPOLLEF)
		elif events == select.EPOLLIN: # 判断事件是接收？
			recvData = connections[fd].recv(1024)
			if recvData:
				print(recvData)
			else
				epoll.unregister(fd)
				connections[fd].close()
```

4. 协程

实现原理，生成器
```python
import time

def A():
    while True:
        print("A")
        yield
        time.sleep(1)


def B(c):
    while True:
        print("B")
        c.__next__()
        time.sleep(1)

if __name__ == "__main__":
    a = A()
    B(a)
```

greenlet模块
```python
from greenlet import greenlet
import time

def test1():
    while True:
        print("a")
        greenlet2.switch()
        time.sleep(1)

def test2():
    while True:
        print("b")
        greenlet1.switch()
        time.sleep(1)

greenlet1 = greenlet(test1)
greenlet2 = greenlet(test2)

greenlet1.switch()
```

greenlet的升级版 ：gevent
```python
import gevent


def f():
    for i in range(5):
        print(gevent.getcurrent(),i)
        gevent.sleep(1)


g1 = gevent.spawn(f)
g2 = gevent.spawn(f)
g3 = gevent.spawn(f)
g1.join()
g2.join()
g3.join()

```

# 5. web静态服务器

```python
from socket import *
import re
from multiprocessing import Process


class staticServer(object):
    """静态服务器类"""

    def __init__(self, port):
        self.server = socket(AF_INET, SOCK_STREAM)
        self.server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        self.server.bind(("", port))

    def handle_socket(self, clientSocket):
        recvData = clientSocket.recv(1024).decode("utf-8")
        # regex = re.compile("^GET / HTTP/1.1\r\nHost: 127.0.0.1:10001\r\nConnection$",re.U)
        # print(regex.findall(recvData))

        lines = recvData.splitlines()
        get_source = re.match(r"\w+\s+(/[^ ]*) ", lines[0])[1]
        if get_source == "/":
            get_source = "/index.html"
        if get_source.endswith(".py"):
            pass
        try:
            file_open = open("."+get_source, "r")
            file_data = file_open.read()
            response = "HTTP/1.1 200 OK\r\n" + "Server:My server\r\n" + "\r\n" + file_data
            clientSocket.send(response.encode("utf-8"))
        except:
            response = "HTTP/1.1 404 Not Found\r\n" + "Server:My server\r\n" + "\r\n" + "not found"
            clientSocket.send(response.encode("utf-8"))
        clientSocket.close()

    def start(self):
        self.server.listen(128)
        while True:
            clientSocket, clientAddress = self.server.accept()
            pro = Process(target=self.handle_socket, args=(clientSocket,))
            pro.start()



def main():
    static_server = staticServer(8081)
    static_server.start()

if __name__ == "__main__":
    main()
```

# 6. web动态服务器框架

1. 换行符
```
linux \n
unix \n
mac \n
windows \r\n
ctrl + c 直接杀死程序
Ctrl + z 将程序放在后台执行
```

2. WSGI web server 通用接口

```python
from socket import *
import re
from multiprocessing import Process


class staticServer(object):
    """静态服务器类"""

    def __init__(self, port):
        self.server = socket(AF_INET, SOCK_STREAM)
        self.server.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        self.server.bind(("", port))

    def start_response(self, status, headers):
        response_headers = "HTTP/1.1 " + status + "\r\n"
        for header in headers:
            response_headers += "%s: %s\r\n" % header
        self.response_headers = response_headers

    def handle_socket(self, clientSocket):
        recvData = clientSocket.recv(1024).decode("utf-8")
        # regex = re.compile("^GET / HTTP/1.1\r\nHost: 127.0.0.1:10001\r\nConnection$",re.U)
        # print(regex.findall(recvData))

        lines = recvData.splitlines()
        get_source = re.match(r"\w+\s+(/[^ ]*) ", lines[0])[1]
        if get_source == "/":
            get_source = "/index.html"
        # 动态文件的处理
        if get_source.endswith(".py"):
            modules = __import__(get_source[1:-3])
            env = {}
            response_body = modules.application(env, self.start_response)
            response = self.response_headers + "\r\n" + response_body
            clientSocket.send(response.encode("utf-8"))
        else:
            try:
                file_open = open("." + get_source, "r")
                file_data = file_open.read()
                response = "HTTP/1.1 200 OK\r\n" + "Server:My server\r\n" + "\r\n" + file_data
                clientSocket.send(response.encode("utf-8"))
            except:
                response = "HTTP/1.1 404 Not Found\r\n" + "Server:My server\r\n" + "\r\n" + "not found"
                clientSocket.send(response.encode("utf-8"))
        clientSocket.close()

    def start(self):
        self.server.listen(128)
        while True:
            clientSocket, clientAddress = self.server.accept()
            pro = Process(target=self.handle_socket, args=(clientSocket,))
            pro.start()


def main():
    static_server = staticServer(8081)
    static_server.start()


if __name__ == "__main__":
    main()

```
```python
import time


# environ是字典形式的解析好的 request信息
def application(environ, start_response):
    status = "200 OK"
    headers = [
        ("Content-Type","text/plain")
    ]
    start_response(status,headers)
    return time.ctime()

```

最近闲在家中，把Python网络编程的内容过了一遍，大致总结如下 socket(文中没有涉及原始套接字，喜欢玩攻防的小伙伴可自行google), TFTP简单文本传输协议的基本实现（有详细的demo） udp tcp 编程，并行并发的区别，进程，线程，协程(selec,epoll)的区别，简单的web服务器demo……